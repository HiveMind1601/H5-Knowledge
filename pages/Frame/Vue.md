Vue.js
	一个构建数据驱动的 web 界面的渐进式框架
	Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件
	MVVM框架
	时间是：2014年
	它的作者是：尤雨溪

插值表达式及数据绑定
	el指向的页面的节点元素，data指定的是数据，{{ title }}两个大括号的语法方式叫“插值表达式”
	简单数据类型、复杂数据类型、函数等都可以在插值表达式中进行显示，并且不需要写this.title，也不需要写data，我们的函数编写在methods内，直接{{ fn() }}调用即可
	v-model(双向数据绑定)可以绑定data的对象值，v-on可以绑定methods下定义的方法，而v-on的缩写则是@
	vue中不能在任何html标签的属性值中使用{{ property }}进行设置，需要通过v-bind进行属性值的数据绑定,v-bind的缩写则是:
	v-once可以让节点渲染的时候只允许渲染一次，就算是方法里重新设置也不作更新
	如果设置的属性是一个html标签类型的内容，那么，直接用表达式方式将会输出“未加工”过的字符串内容，如果想要让其显示其html的内容形式，可以利用v-html的方式进行数据绑定

事件
	事件方法编写在methods中，可以利用v-on进行对象的事件绑定
	如果是鼠标移动事件的绑定，可以利用v-on:mousemove进行绑定，函数中可带参数event，通过event来获取事件传递的属性
	函数的参数传递，可以将事件$event作为参数传递到函数中
	事件可附带修饰符，修饰符除了有stop、prevent、capture、native、self还有键别名enter及键代码13的修饰符

DOM交互
	在DOM元素中利用表达式进行三目运算操作
	methods(方法)与computed(计算(属性的计算))的差异：(都可以实现相同功能,computed能实现的methods都能实现)
方法每次调用的时候都要触发方法(主动请求才会触发),计算将会被内存缓存到内存机制里(下一次调用是被动式调用(对象发生改变时才会被执行))
	利用watch可以对对象内容进行监控操作，但需要注意this对象的不同

样式处理
	可以利用:class实现样式的动态绑定
		进行了一次类的样式的动态绑定,绑定的对象是object(格式),
建名是类名,建值是布尔值,如果为true则将指定建名的类名加到该对象上,为false则去除
		变量名以及对象形式的样式设置可以同时以数组的形式设置到页面的DOM对象中去
	通过computed以及对象属性的设置，可以对DOM设置Object形式的样式内容，通过条件判断到底需要调用哪一种样式内容，而对象的键名即可以是样式类名
	单独样式设置可以利用:style进行操作，但是需要注意属性的书写格式将变成驼峰式编写方式，并且-符号将会去除，例如：background-color将书写成backgroundColor
		style可以设置为数组结构形式，其中的内容既可以包含变量，也可以包含驼峰式书写方式的样式内容，并且样式中还可以调用设置的变量或者动态计算的变量值等

条件、循环句语
	v-if和v-else能够实现在DOM节点中的判断操作
	如果是多DOM节点，则可以利用template进行包含，再用v-show对它进行判断是否显示与隐藏
	v-show操作节点的话，元素节点还是存在的
		v-if/v-show都是惰性的
	v-for
		for循环是something in something
key帮助快速查找,优化性能
		v-for在template中同样也可以作用
		v-for同样可以循环对象，包括循环嵌套输出。对于对象的循环，可以利用key/value/index进行输出相应的内容

实例化
	单个基本实例，包括el、data、methods、computed、watch等内容
	对于Vue对象内容，可以利用ref来进行指定与识别，该操作有些类似HTML中的Id方式
		ref相当于id,$refs是包含ref的对象
	声明对象为Vue的实例，可以利用“实例对象.属性”的方式在外面修改某个实例的属性值
	在构建Vue实例时可以设置其template模板内容，再使用$mount来进行对象的加载，然后将“实例对象.$el ”显示在具体的页面中
	Vue实例对象的生命周期的钩子函数包括： beforeCreate、 created、 mounted、 updated、 beforeDestroy、 destroyed等
		与代码的执行顺序无关

Vue-CLI
	package.json中的script是运行的命令行缩写
	webpack.config.js
		前端自动化构建工具(webpack/gulp)
		遵循commonJS规范
		手动配置webpack的流程
			1)入口文件的设置
			2)出口文价的配置
			3)加载器的使用
			4)外部插件管理
		map映射文件
	加载器
		css-loader/sass-loader/vue-loader....
			加载器就是对指定文件进行转化操作工作,顺序是从右向左执行

组件
	组件的创建与Vue对象的创建一样，也可以包含data、template和methods等内容
		如果将data设置在全局变量中，并且在组件中return data以后，通过组件按钮改变对象值的话，所有组件对象值都将改变。因而需要控制每个组件都有自己独立的状态值对象，则需要将变量设置并返回在组件当中，不能设置为全局变量
	组件的注册模式分为全局注册模式以及本地注册模式，顾名思义，全局注册将在所有对象中使用组件（单数），而本地注册则可以限定不同的实例对象使用不同的本地组件（复数）
	data在组件中是函数不能是对象
		是函数的话,就是数据只作用在当前组件内,（闭包）


组件关系
	父与子
		属性绑定（父组件绑定属性）
			String
			Number
			Array
			Object
			Function
			...
		属性接收（子组件进行属性接收）
			props进行接收
				array
				object
	子与父
		回调模式
			父组件绑定函数
			子组件接收并触发函数
			传递参数到父组件的函数中去
			再由父组件修改data中的数据
		emit模式
			子组件中进行$emit数据发射操作
			父组件中进行事件的监听,并且接受event事件的对象内容
			通过event事件对象内容再修改data数据
	非父子
		公交总线
			新建一个Vue实例，这个实例与原Vue实例处同级并列关系
			那么所有的组件与该实例只处上下级关系
			再某组件中进行$emit事件发射，发射到bus总线的Vue实例中
			在想要接收并操作数据的组件当中进行事件监听，并且接收event事件对象



slot插槽
	slot可以将组件标签中的内容进行插槽式的显式
	也可以利用slot name的方式指定显示slot的内容
	如果不给slot定义name，那么就是默认的slot显示
	也可以直接在子组件中定义slot的默认值，如果父组件中有传递，那么就显示传递值，否则就是slot的默认值
	componrent可以实现动态组件的加载，绑定的属性是 ：is
	可以利用keep-alive将加载的组件保持状态
	组件的钩子函数新增
		activated
		deactivated